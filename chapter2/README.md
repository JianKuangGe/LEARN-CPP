> 如果说上一章是让你了解C++的话，那么从这一章开始就是正式学习C++了
>
> 大多数的编程语言都少不了下面这些内容：
>
> 数据类型、表达式、语句、函数、类
>
> 接下来的二到七章，我们要学习的就是上述内容。

> 本章(第二章)我们要学习的是“变量和基本数据类型”

基本数据类型包括算数类型和空类型(void)

算数类型又分两类：整型(包括字符和布尔在内)和浮点型

C++标准规定了类型的最小尺寸，比较常见的有：

- char 8bit
- int 16bit
- long 32bit
- long long 64bit
- float 6位有效数字
- double 10位有效数字

选择类型的建议:

1. 当明确知晓数值不可能为负时，选择无符号类型。
2. 实际中，long一般和int拥有一样的尺寸，如果数值超过了int的表示范围，通常使用long long。
3. 执行浮点运算选用double，因为float通常精度不够，且float和double的计算代价相差无几，一般情况下不用使用long double,它会带来额外的运行时消耗。

---

类型转换

当在程序中我们使用了一种类型而其实对象应该读取另一种类型时，程序会自动进行类型转换。

![image-20231017175034512](../../../Library/Application Support/typora-user-images/image-20231017175034512.png)

程序应该尽量避免依赖于实现环境的行为。

可能引发隐式的类型转换的情况有如下：

1. 把一种算数类型的值赋予另外一种类型。
2. 当程序中的某处使用了一种算数类型中的值而实际所需的是另一种类型的值。例如while(5)
3. 含有无符号类型的表达式，当带符号类型为负数时，带符号类型会被转换成无符号类型。

---

字面值常量

- 十进制：20
- 八进制：020
- 十六进制：0x20

由单引号引起的一个字符称为char型字面值

双引号引起的零个或多个字符称为字符串字面值

字符串字面值实际是由常量字符构成的数组

编译器在每个字符串的结尾处添加一个空字符('\0'),所以字符串长度比它实际内容多1

多行字符串：

![image-20231017182206151](../../../Library/Application Support/typora-user-images/image-20231017182206151.png)

---

对象是指一块能存储数据并具有某种类型的内存空间。

要注意的是初始化和赋值不是一个东西。

使用花括号进行初始化的形式称为列表初始化，这种方式的好处是，如果我们使用列表初始化且初识值存在丢失信息的风险时，编译器会报错，例如（extra1）：

double id = 3.14;

int a = {id};

很遗憾，当我在extra1中使用如下代码时,编译器并没有报错，并且使用int a{id}的方式进行初始化会报错。

```cpp
// 确认列表初始化存在丢失信息风险时的编译器报错

# include <iostream>

int main()
{
    long double m = 3.1415926536;
    int n{m}, i = {m};
//    std::cout << n << i <<std::endl;
    return 0;
}

❯ g++ -o extra1 ./main.cc
./main.cc:8:10: error: expected ';' at end of declaration
    int n{m}, i = {m};
         ^
         ;
1 error generated.
```

---

默认初始化

如果定义变量时没有初始化，则变量会被默认初始化，定义在函数体内部的内置类型变量将不被初始化，参考practice2.10中local_int的值在每次程序执行时都不一样。

建议初始化每一个内置类型的变量，使用未初始化变量的值是一种错误的编程行为，并很难调试，所以一定要避免。

---

声明和定义

声明一个变量使用关键字extern,例如extern int i;

声明是为了什么？是为了能够跨文件共用变量，参考extra2,我在extern.h中定义了一个变量i,那我想在main中使用这个i需要怎么做呢，肯定不能是用int i;因为这样会重新生成一个名为i的变量，这时候声明的作用就体现出来了，“声明”在这里的作用就是，我想要使用这个名字的变量，但并不是重新定义它。

变量能且只能被定义一次，但是可以被多次声明.

任何包含了显示初始化的声明即成为定义，如extern int i = 5;

---

变量命名规范：

1. 变量名一般全部小写
2. 自定义的类名一般大写字母开头

用户自定义的标识符有以下要求：

1. 不能连续出现两个下划线
2. 不能以下划线紧连大写字母开头
3. 定义在函数体外的标识符不能以下划线开头

---

作用域

一般来说，在对象第一次被使用的地方附近定义它是一个好的选择。

---

复合类型

引用

复合类型就是基于其它类型定义的类型，包括引用、指针等

我们通常说的引用是指“左值引用”

“引用”相当于给变量起了另一个名字，通过&符号进行定义，例如：

int m = 5;

int &n = m;

这里就是定义了一个名为n的引用，n就是m的另一个别名，它俩在内存中实际是同一个东西。

因为“引用”不是一个对象，所以不能定义“引用”的引用。

引用只能绑定到对象上，不能绑定到某个字面值或表达式的计算结果。

引用就是别名，请忘记地址之类的东西

---

指针

指针跟引用类似，都是实现了对其它对象的间接访问，但又有些不同：

1. 指针本身也是一个对象
2. 指针无需在定义时赋值，如果在块作用域内定义没有被初始化时，它将拥有一个不确定的值(非常危险的操作)

定义指针：

定义指针类型的符号是*

指针存放某个对象的地址，要想获得该地址，需要使用取地址符&

int i = 5;

int *p = &i;

此时p中存放的就是i的地址了。

利用指针访问对象：

如果指针指向了一个对象，则使用解引用符*来访问该对象。

int i = 5;

int *p = &i;

cout << *p;

---

关于*和&

- &出现在左侧时为定义引用，右侧时为取地址符

- *出现在左侧时为定义指针，右侧时为解引用符

---

空指针

不指向任何对象的指针

定义空指针的方法：

- int *p1 = nullptr;
- int *p2 = 0;

把int变量直接赋值给指针是错误的操作，即使int变量的值恰好为0也不行。

严禁使用未经初识化的指针，所有的指针在定义时都要做初始化。

---

void*指针

void*指针可以存放任意类型对象的地址

---

指针和引用的区别：

引用是类似别名的东西并不是一个实际的对象，指针存放着对象的地址，指针本身也是一个对象。

---

复合类型的声明

基本数据类型和修饰符：

- 基本数据类型是指int,double这种
- 修饰符是指*和&这种

上面的联系有个题目，定义一个指针int\* lp = i;  

这种行为是合法的，但是会有个问题，那就是这个*会修饰后续的所有变量吗，例如\*int lp1 = i, lp2 = i;

这种情况下lp2是int类型的指针还是int类型的变量，答案是int类型的变量，\*只会修饰到lp2

---

指向指针的指针

\*表示一个指针，\*\*表示指向指针的指针,下面的ppi就是一个指向指针的指针

```cpp
int val = 5;
int * pi = &val;
int **ppi = &pi;
```

---

指向指针的引用

引用本身不是一个对象，因此不能定义指向引用的指针。但是我们可以定义指向指针的引用。

```cpp
int i = 5;
int *p;
int *&r = p;
```

要看一个变量的类型到底是什么，可以看离它最近的修饰符，例如这里的r，离它最近的是&，所以r是一个引用

---

const限定符

我们需要定义这样一种变量，它的值不能被修改，就可以使用const限定符。防止该变量被程序意外修改。

默认状态下，const对象尽在文件内有效，编译器在编译时会把所有用到该变量的地方通通进行替换。

但如果我们想让const变量跨文件使用呢，我们可以通过之前学过的声明(extern)，在定义和声明前都添加该关键字。

因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。

```cpp
// 定义
extern const int i = 5;
// 使用
extern const int i;
```

---

const的引用

对常量的引用通常称之为常量引用。

```cpp
const int i = 5;
const int &r1 = i;

// 以下方式是错误的，因为这试图把一个非常量的引用指向一个常量
int &r2 = i;
```

前面有提过引用的类型必须和其引用对象的类型一直，但是当引用为常量引用是会有一个特殊情况，即：常量引用允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。例如：

```cpp
double i = 3.14;
const int &ri = i;
```

上面这个操作是合法的，为什么呢，我们需要了解下常量引用时，到底发生了什么，如下，会先创建一个临时量用来保存对象的的值，再将对象引用指向该临时量对象。

```cpp
const int temp = i;
const int &ri = temp;
```

那为什么非常量引用时就要求类型一致呢，因为非常量引用时不会有这个临时量，是直接将引用绑定在了对象上。

---

常量引用的对象可以是非常量。

详见extra3，这段代码中我先是把i定义为int类型，发现i重新赋值后r1也会跟着变化，但是将i定义为double类型后，对i重新赋值后，r1不会变化，这就说明：

当常量引用的类型和对象的类型一致时，不会使用临时量，

当常量引用的类型和对象的类型不一致时，会使用临时量，常量引用的值被初始化后，都不会再变

```cpp
#include <iostream>

int main()
{
    double i = 3.1415;
    const int &r1 = i;
    std::cout << "Before assignment: " << r1 << std::endl;
    i = 6.1223;
    std::cout << "After assignment: " << r1 << std::endl;
}
```

---

指针和const

和引用类似，也可以让指针指向常量。

- 要想指向常量对象，则必须使用指向常量的指针
- 指向常量的指针也可以指向一个非常量对象，通过临时量实现

跟常量引用不太一样，指针是一个对象，因此可以把指针本身定义为一个常量，如下：

```cpp
int i = 5;
// 这里定义了一个常量指针p1
int *const p1 = &i;

// 这里定义了一个指向常量对象的常量指针p2
const int *consr p2 = &i;
```

// 1. 引用在定义时必须进行初始化

// 2. 常量指针在定义时必须进行初始化

// 3. 常量指针不能被再次复制

---

顶层const和底层const

- 顶层const：表示自身就是一个常量
- 底层const: 表示自身所指的对象是一个常量

---

constexpr和常量表达式

常量表达式是指指不会改变并且编译过程就能得到结果的表达式。

需要两个条件：

1. 本身是个常量const
2. 初始化为字面量

在实际应用中我们很难分辨一个值是不是常量表达式，例如会存在下面这种情况:

```cpp
const int m = 5;
const int n = m + 5;
```

c++11中允许将变量声明为constexpr类型，一变让编译器验证是否为常量表达式

```cpp
const int m = 5;
constexpr int n = m + 5;
```

constexpr int \*q = =nullptr;

此时q是一个指针常量，constexpr把q置为了顶层const

---

类型别名

类型别名，我们可以给一个类型起一个别名，通过typedef关键字

```cpp
// 这里给double起了一个别名aaa
typedef double aaa;
// 这里ppp是指double*
typedef aaa bbb, *ppp;
```

新标准中又有一个新方法起别名，通过别名声明

```cpp
using aaa = double;
```



需要注意的是使用别名指代复合类型有时会产生意想不到的后果：

```cpp
// 这里定义p时一个int类型的指针
typedef int *p;

// 需要注意的是这里定义的p1是一个指向int的常量指针
// 而不是简单的将p替换成int * ,形成const int * p1,这样是错误的，因为这样的p1是一个指向int常量的指针
const p p1 = &i;
```

---

auto类型说明符

编程时常常会把表达式的值赋值给变量，但是有时表达式的数据类型不那么好看出来，于是c++新标准就出现了个关键字auto，能自动的根据表达式的数据类型进行定义，如：

```cpp
int i = 5, m = 10;
auto n = i + m;
// 编译器会自动推导出n为int类型
```

但是一条语句只能有一个基本的数据类型，因此下列情况是不被允许的：

```cpp
auto a = 5, b = 3.14;
```

当表达式是一个复合类型呢，auto通常会忽视顶层const，而保留底层const

---

decltype



// TODO

// 待做







---























































